# BALTIDE_Brandon_TP6_ST2TRD
*** Crucial information : it is TP6 and not TP5 
*** Answer of the questions ***

Exercice 1 : 
A clean code is a way to code that :
	- is obvious for others programmers
	-  dosent’ contain duplication 
	- contains a minimal number of classes and other moving part
	- pass all tests
	- is cheaper and easier to maintain
2. Yes it is possible. It happens when you move away from refactoring with small changes and mix a whole bunch of refactorings into one big change

3. Code smell is all the bad habits inexperienced programmers have such as : 
	- Bloasters : code, methods and classes that have increased to such 			gargantuan proportions that they are hard to work with.
	- Object oriented abuser : 
		-Switch Statements
		-Temporary Field
		-Refused Bequest :  subclasses doesn’t implement all the inherited method 
		- Alternative Classes with Different Interfaces : Two classes perform identical functions but have different method names.
	- The change preventers : mean that if you need to change something in one place in your code, you have to make many 	changes in other places too. Program development becomes much 			more complicated and expensive as a result.
	- Dispensable : absence of those would clean the code 
	- Couplers : All the smells in this group contribute to excessive coupling between classes or show what happens if coupling is 			replaced by excessive delegation.
4. The nested if statement 	
5.	 - Composing Methods
	-Simplifying Conditional expressions(Replace Nesed Conditional,Replace Conditional with Polymorphism)
	- Dealing with generalization

Exercice 2 : 
Design Pattern is a couple(Problem/Solution) it helps to find the situation in which you should follow the Gamma principle and how to use them. Your code will be reusable and scalable.
No need to force your code to implement all the design patters. You need to distinguished the situation (problem) and fix the problem with the proper patterns 
It exist categories of them : 
Creational :object creation mechanisms that increase flexibility and reuse of existing code.
Structural : explain how to assemble objects and classes into larger structures, while keeping the structures flexible and efficient.
Behavioral : take care of effective communication and the assignment of responsibilities between objects.
